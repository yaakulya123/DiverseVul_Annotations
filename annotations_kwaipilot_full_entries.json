[
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-264",
        "CVE": "CVE-2012-3365",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static char *make_filename_safe(const char *filename TSRMLS_DC)\n{\n\tif (*filename && strncmp(filename, \":memory:\", sizeof(\":memory:\")-1)) {\n\t\tchar *fullpath = expand_filepath(filename, NULL TSRMLS_CC);\n\n\t\tif (!fullpath) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (PG(safe_mode) && (!php_checkuid(fullpath, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (php_check_open_basedir(fullpath TSRMLS_CC)) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn fullpath;\n\t}\n\treturn estrdup(filename);\n}"
        },
        "vulnerabilities": "Improve check for :memory: pseudo-filename in SQlite",
        "annotation": "[Mandatory] ID: \nCVE-2012-3365\n\n[Mandatory] Title: CVE-2012-3365 / CWE-264: \nImprove check for :memory: pseudo-filename in SQlite\n\n[Optional] Disclosure / Patch Dates:\nNot available in input\n\n[Optional] Affected products/versions:\nNot available in input\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n Improper access controls\n[Mandatory] Summary:\nThe vulnerability is in SQLite's handling of the :memory: pseudo-filename, where insufficient validation allows for improper access control. The bug occurs when SQLite processes database connection requests using the special :memory: filename, potentially allowing unintended access or manipulation of in-memory database resources. This could be triggered through any application that uses SQLite and accepts user-controlled database filenames.\n[Mandatory] Root cause:\nInsufficient validation of the :memory: pseudo-filename parameter in SQLite's database opening logic.\n[Mandatory] Attack Surface:\nSQLite database engine - library-level interface\n[Mandatory] Impact Summary: \nLocal privilege escalation / unauthorized data access\n[Optional] Trigger / Attack vector:\nDatabase filename parameter in sqlite3_open() or related APIs\n[Mandatory] Key code/struct excerpt (minimal):\n\nNot available in input\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nSQLite database filename parameter in sqlite3_open() or related APIs\n\n[Mandatory] Exploit primitive(s) available:\nUnauthorized database access, potential data disclosure\n\n[Mandatory] Exploitability summary (1 sentence):\nModerate exploitability requiring local code execution to invoke SQLite APIs with malicious filename parameters.\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Craft malicious database filename using :memory: pseudo-filename\n- Invoke SQLite API (sqlite3_open) with crafted filename\n- Bypass intended access controls for in-memory databases\n- Access or manipulate database resources beyond intended scope\n- Escalate privileges or access unauthorized data\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNot available in input\n[Optional] Patch Analysis:\nNot available in input\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n- Review other SQLite pseudo-filenames and special handling\n- Audit access control checks for database file operations\n- Test edge cases in SQLite filename parsing logic\n\n[Optional] Likely variants/impact (one line):\nSimilar issues may exist in other SQLite filename validation routines\n\nEND INSTRUCTION.",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 1650,
            "output_tokens": 533
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "NVD-CWE-Other",
        "CVE": "CVE-2006-1168",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "unpack_Z_stream(int fd_in, int fd_out)\n{\n\tIF_DESKTOP(long long total_written = 0;)\n\tIF_DESKTOP(long long) int retval = -1;\n\tunsigned char *stackp;\n\tlong code;\n\tint finchar;\n\tlong oldcode;\n\tlong incode;\n\tint inbits;\n\tint posbits;\n\tint outpos;\n\tint insize;\n\tint bitmask;\n\tlong free_ent;\n\tlong maxcode;\n\tlong maxmaxcode;\n\tint n_bits;\n\tint rsize = 0;\n\tunsigned char *inbuf; /* were eating insane amounts of stack - */\n\tunsigned char *outbuf; /* bad for some embedded targets */\n\tunsigned char *htab;\n\tunsigned short *codetab;\n\n\t/* Hmm, these were statics - why?! */\n\t/* user settable max # bits/code */\n\tint maxbits; /* = BITS; */\n\t/* block compress mode -C compatible with 2.0 */\n\tint block_mode; /* = BLOCK_MODE; */\n\n\tinbuf = xzalloc(IBUFSIZ + 64);\n\toutbuf = xzalloc(OBUFSIZ + 2048);\n\thtab = xzalloc(HSIZE);  /* wsn't zeroed out before, maybe can xmalloc? */\n\tcodetab = xzalloc(HSIZE * sizeof(codetab[0]));\n\n\tinsize = 0;\n\n\t/* xread isn't good here, we have to return - caller may want\n\t * to do some cleanup (e.g. delete incomplete unpacked file etc) */\n\tif (full_read(fd_in, inbuf, 1) != 1) {\n\t\tbb_error_msg(\"short read\");\n\t\tgoto err;\n\t}\n\n\tmaxbits = inbuf[0] & BIT_MASK;\n\tblock_mode = inbuf[0] & BLOCK_MODE;\n\tmaxmaxcode = MAXCODE(maxbits);\n\n\tif (maxbits > BITS) {\n\t\tbb_error_msg(\"compressed with %d bits, can only handle \"\n\t\t\t\tBITS_STR\" bits\", maxbits);\n\t\tgoto err;\n\t}\n\n\tn_bits = INIT_BITS;\n\tmaxcode = MAXCODE(INIT_BITS) - 1;\n\tbitmask = (1 << INIT_BITS) - 1;\n\toldcode = -1;\n\tfinchar = 0;\n\toutpos = 0;\n\tposbits = 0 << 3;\n\n\tfree_ent = ((block_mode) ? FIRST : 256);\n\n\t/* As above, initialize the first 256 entries in the table. */\n\t/*clear_tab_prefixof(); - done by xzalloc */\n\n\tfor (code = 255; code >= 0; --code) {\n\t\ttab_suffixof(code) = (unsigned char) code;\n\t}\n\n\tdo {\n resetbuf:\n\t\t{\n\t\t\tint i;\n\t\t\tint e;\n\t\t\tint o;\n\n\t\t\to = posbits >> 3;\n\t\t\te = insize - o;\n\n\t\t\tfor (i = 0; i < e; ++i)\n\t\t\t\tinbuf[i] = inbuf[i + o];\n\n\t\t\tinsize = e;\n\t\t\tposbits = 0;\n\t\t}\n\n\t\tif (insize < (int) (IBUFSIZ + 64) - IBUFSIZ) {\n\t\t\trsize = safe_read(fd_in, inbuf + insize, IBUFSIZ);\n//error check??\n\t\t\tinsize += rsize;\n\t\t}\n\n\t\tinbits = ((rsize > 0) ? (insize - insize % n_bits) << 3 :\n\t\t\t\t  (insize << 3) - (n_bits - 1));\n\n\t\twhile (inbits > posbits) {\n\t\t\tif (free_ent > maxcode) {\n\t\t\t\tposbits =\n\t\t\t\t\t((posbits - 1) +\n\t\t\t\t\t ((n_bits << 3) -\n\t\t\t\t\t  (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));\n\t\t\t\t++n_bits;\n\t\t\t\tif (n_bits == maxbits) {\n\t\t\t\t\tmaxcode = maxmaxcode;\n\t\t\t\t} else {\n\t\t\t\t\tmaxcode = MAXCODE(n_bits) - 1;\n\t\t\t\t}\n\t\t\t\tbitmask = (1 << n_bits) - 1;\n\t\t\t\tgoto resetbuf;\n\t\t\t}\n\t\t\t{\n\t\t\t\tunsigned char *p = &inbuf[posbits >> 3];\n\n\t\t\t\tcode = ((((long) (p[0])) | ((long) (p[1]) << 8) |\n\t\t\t\t         ((long) (p[2]) << 16)) >> (posbits & 0x7)) & bitmask;\n\t\t\t}\n\t\t\tposbits += n_bits;\n\n\n\t\t\tif (oldcode == -1) {\n\t\t\t\toldcode = code;\n\t\t\t\tfinchar = (int) oldcode;\n\t\t\t\toutbuf[outpos++] = (unsigned char) finchar;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (code == CLEAR && block_mode) {\n\t\t\t\tclear_tab_prefixof();\n\t\t\t\tfree_ent = FIRST - 1;\n\t\t\t\tposbits =\n\t\t\t\t\t((posbits - 1) +\n\t\t\t\t\t ((n_bits << 3) -\n\t\t\t\t\t  (posbits - 1 + (n_bits << 3)) % (n_bits << 3)));\n\t\t\t\tn_bits = INIT_BITS;\n\t\t\t\tmaxcode = MAXCODE(INIT_BITS) - 1;\n\t\t\t\tbitmask = (1 << INIT_BITS) - 1;\n\t\t\t\tgoto resetbuf;\n\t\t\t}\n\n\t\t\tincode = code;\n\t\t\tstackp = de_stack;\n\n\t\t\t/* Special case for KwKwK string. */\n\t\t\tif (code >= free_ent) {\n\t\t\t\tif (code > free_ent) {\n\t\t\t\t\tunsigned char *p;\n\n\t\t\t\t\tposbits -= n_bits;\n\t\t\t\t\tp = &inbuf[posbits >> 3];\n\n\t\t\t\t\tbb_error_msg\n\t\t\t\t\t\t(\"insize:%d posbits:%d inbuf:%02X %02X %02X %02X %02X (%d)\",\n\t\t\t\t\t\t insize, posbits, p[-1], p[0], p[1], p[2], p[3],\n\t\t\t\t\t\t (posbits & 07));\n\t\t\t\t\tbb_error_msg(\"corrupted data\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t*--stackp = (unsigned char) finchar;\n\t\t\t\tcode = oldcode;\n\t\t\t}\n\n\t\t\t/* Generate output characters in reverse order */\n\t\t\twhile ((long) code >= (long) 256) {\n\t\t\t\t*--stackp = tab_suffixof(code);\n\t\t\t\tcode = tab_prefixof(code);\n\t\t\t}\n\n\t\t\tfinchar = tab_suffixof(code);\n\t\t\t*--stackp = (unsigned char) finchar;\n\n\t\t\t/* And put them out in forward order */\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\ti = de_stack - stackp;\n\t\t\t\tif (outpos + i >= OBUFSIZ) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (i > OBUFSIZ - outpos) {\n\t\t\t\t\t\t\ti = OBUFSIZ - outpos;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tmemcpy(outbuf + outpos, stackp, i);\n\t\t\t\t\t\t\toutpos += i;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (outpos >= OBUFSIZ) {\n\t\t\t\t\t\t\tfull_write(fd_out, outbuf, outpos);\n//error check??\n\t\t\t\t\t\t\tIF_DESKTOP(total_written += outpos;)\n\t\t\t\t\t\t\toutpos = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstackp += i;\n\t\t\t\t\t\ti = de_stack - stackp;\n\t\t\t\t\t} while (i > 0);\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(outbuf + outpos, stackp, i);\n\t\t\t\t\toutpos += i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Generate the new entry. */\n\t\t\tcode = free_ent;\n\t\t\tif (code < maxmaxcode) {\n\t\t\t\ttab_prefixof(code) = (unsigned short) oldcode;\n\t\t\t\ttab_suffixof(code) = (unsigned char) finchar;\n\t\t\t\tfree_ent = code + 1;\n\t\t\t}\n\n\t\t\t/* Remember previous code.  */\n\t\t\toldcode = incode;\n\t\t}\n\n\t} while (rsize > 0);\n\n\tif (outpos > 0) {\n\t\tfull_write(fd_out, outbuf, outpos);\n//error check??\n\t\tIF_DESKTOP(total_written += outpos;)\n\t}\n\n\tretval = IF_DESKTOP(total_written) + 0;\n err:\n\tfree(inbuf);\n\tfree(outbuf);\n\tfree(htab);\n\tfree(codetab);\n\treturn retval;\n}"
        },
        "vulnerabilities": "uncompress: fix buffer underrun by corrupted input\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>",
        "annotation": "[Mandatory] ID: \nCVE-2006-1168\n\n[Mandatory] Title: CVE-2006-1168 / CWE-NVD-CWE-Other: \nuncompress buffer underrun fix\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nNot available in input\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n buffer underrun\n[Mandatory] Summary:\nThe vulnerability exists in the uncompress function where corrupted input can trigger a buffer underrun condition. The bug occurs when malformed data causes the decompression routine to read before the allocated buffer boundary, potentially leading to memory corruption or program crash. This is exploitable by providing specially crafted compressed data to any interface using this uncompress implementation.\n[Mandatory] Root cause:\nUnchecked input validation during decompression allows corrupted data to cause buffer underrun.\n[Mandatory] Attack Surface:\nData decompression interface\n[Mandatory] Impact Summary: \nMemory corruption via buffer underrun\n[Optional] Trigger / Attack vector:\nMalformed compressed data\n[Mandatory] Key code/struct excerpt (minimal):\n\n[small code snippet or struct showing the flaw  ≤15 lines]\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nCompressed data input to uncompress function\n[Mandatory] Exploit primitive(s) available:\nBuffer underrun leading to memory corruption\n[Mandatory] Exploitability summary (1 sentence):\nExploitable through malformed compressed input with potential for controlled memory corruption.\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Craft malformed compressed data triggering buffer underrun\n- Supply data to uncompress function via file, network, or API\n- May cause crash or memory corruption depending on input\n- Could potentially be weaponized for denial of service\n- No known public exploit code available\n- Requires access to uncompress interface\n\nFix\n[Mandatory] Fix code:\nNA\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNot available in input\n[Optional] Patch Analysis:\n[Short note: \"What did the fix do?\"\n - Field: PatchType (e.g., bounds check added, logic refactor, feature removal)\nNot available in input\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\nNot available in input\n\n[Optional] Likely variants/impact (one line):\nNot available in input",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 1686,
            "output_tokens": 527
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-787",
        "CVE": "CVE-2007-1320",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static void cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h)\n{\n    int sx, sy;\n    int dx, dy;\n    int width, height;\n    int depth;\n    int notify = 0;\n\n    depth = s->get_bpp((VGAState *)s) / 8;\n    s->get_resolution((VGAState *)s, &width, &height);\n\n    /* extra x, y */\n    sx = (src % (width * depth)) / depth;\n    sy = (src / (width * depth));\n    dx = (dst % (width *depth)) / depth;\n    dy = (dst / (width * depth));\n\n    /* normalize width */\n    w /= depth;\n\n    /* if we're doing a backward copy, we have to adjust\n       our x/y to be the upper left corner (instead of the lower\n       right corner) */\n    if (s->cirrus_blt_dstpitch < 0) {\n\tsx -= (s->cirrus_blt_width / depth) - 1;\n\tdx -= (s->cirrus_blt_width / depth) - 1;\n\tsy -= s->cirrus_blt_height - 1;\n\tdy -= s->cirrus_blt_height - 1;\n    }\n\n    /* are we in the visible portion of memory? */\n    if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 &&\n\t(sx + w) <= width && (sy + h) <= height &&\n\t(dx + w) <= width && (dy + h) <= height) {\n\tnotify = 1;\n    }\n\n    /* make to sure only copy if it's a plain copy ROP */\n    if (*s->cirrus_rop != cirrus_bitblt_rop_fwd_src &&\n\t*s->cirrus_rop != cirrus_bitblt_rop_bkwd_src)\n\tnotify = 0;\n\n    /* we have to flush all pending changes so that the copy\n       is generated at the appropriate moment in time */\n    if (notify)\n\tvga_hw_update();\n\n    (*s->cirrus_rop) (s, s->vram_ptr + s->cirrus_blt_dstaddr,\n\t\t      s->vram_ptr + s->cirrus_blt_srcaddr,\n\t\t      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    if (notify)\n\ts->ds->dpy_copy(s->ds,\n\t\t\tsx, sy, dx, dy,\n\t\t\ts->cirrus_blt_width / depth,\n\t\t\ts->cirrus_blt_height);\n\n    /* we don't have to notify the display that this portion has\n       changed since dpy_copy implies this */\n\n    if (!notify)\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n}"
        },
        "vulnerabilities": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162",
        "annotation": "[Mandatory] ID: \nCVE-2007-1320\n\n[Mandatory] Title: CVE-2007-1320 / CWE-787: Cirrus VGA bitblt heap overflow\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nQEMU 0.8.2 (as used in Xen and possibly other products)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n Heap buffer overflow\n[Mandatory] Summary:\n Multiple heap-based buffer overflows exist in the cirrus_invalidate_region function within the Cirrus VGA extension of QEMU 0.8.2, which is used in Xen and possibly other virtualization products. The vulnerability is triggered when attempting to mark non-existent memory regions as dirty during bitblt operations, allowing local users to execute arbitrary code by overwriting adjacent heap memory.\n[Mandatory] Root cause:\n Unchecked memory region bounds when marking regions dirty in cirrus_invalidate_region\n[Mandatory] Attack Surface:\n Virtual machine guest-to-host via VGA emulation\n[Mandatory] Impact Summary: \n Local privilege escalation / arbitrary code execution in host\n[Optional] Trigger / Attack vector:\n VGA bitblt operations with crafted region coordinates\n[Mandatory] Key code/struct excerpt (minimal):\n\nNA\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\n Cirrus VGA bitblt operations via I/O ports\n\n[Mandatory] Exploit primitive(s) available:\n Heap buffer overflow with controlled data\n\n[Mandatory] Exploitability summary (1 sentence):\n Exploitable by local guest users through crafted VGA commands, though limited by heap layout predictability\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n\n- Open VGA device and gain access to Cirrus registers\n- Craft bitblt commands with invalid region coordinates that exceed allocated heap buffers\n- Trigger cirrus_invalidate_region with oversized width/height values\n- Overflow adjacent heap metadata or buffers with shellcode\n- Redirect execution flow via corrupted function pointers or heap structures\n- Escalate privileges from guest to host context\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n\n[Optional] Patch reference:\nNA\n\n[Optional] Patch Analysis:\nNA\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n\n- Review all region validation in Cirrus VGA emulation functions\n- Audit other bitblt-related operations for similar boundary issues\n- Check VGA register handlers for unchecked user inputs\n\n[Optional] Likely variants/impact (one line):\nSimilar overflows likely exist in other Cirrus VGA functions handling region operations\n\nEND INSTRUCTION.",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2042,
            "output_tokens": 573
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-787",
        "CVE": "CVE-2007-1320",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,\n                             uint8_t *dst,const uint8_t *src,\n                             int dstpitch,int srcpitch,\n                             int bltwidth,int bltheight)\n{\n    int x,y;\n    dstpitch -= bltwidth;\n    srcpitch -= bltwidth;\n    for (y = 0; y < bltheight; y++) {\n        for (x = 0; x < bltwidth; x++) {\n            ROP_OP(*dst, *src);\n            dst++;\n            src++;\n        }\n        dst += dstpitch;\n        src += srcpitch;\n    }\n}"
        },
        "vulnerabilities": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162",
        "annotation": "[Mandatory] ID: \nCVE-2007-1320\n\n[Mandatory] Title: CVE-2007-1320 / CWE-787: Cirrus LGD-54XX bitblt heap overflow\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nQEMU 0.8.2 (as used in Xen and possibly other products)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n Heap-based buffer overflow\n[Mandatory] Summary:\n Multiple heap-based buffer overflows exist in the cirrus_invalidate_region function within the Cirrus VGA extension of QEMU 0.8.2. The vulnerability is triggered when attempting to mark non-existent regions as dirty during bitblt operations. Insufficient bounds checking allows attackers to overflow heap buffers, potentially enabling local users to execute arbitrary code.\n[Mandatory] Root cause:\n Missing bounds checking when marking regions as dirty in cirrus_invalidate_region function\n[Mandatory] Attack Surface:\n QEMU Cirrus VGA virtual graphics device\n[Mandatory] Impact Summary: \n Local privilege escalation / arbitrary code execution\n[Optional] Trigger / Attack vector:\n VGA bitblt operations attempting to mark invalid regions as dirty\n[Mandatory] Key code/struct excerpt (minimal):\n\n[No code excerpt available in input]\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\n Cirrus VGA bitblt operations through virtual graphics interface\n\n[Mandatory] Exploit primitive(s) available:\n Heap buffer overflow with potential write-what-where capability\n\n[Mandatory] Exploitability summary (1 sentence):\n The heap overflow is exploitable by local attackers with access to the virtual graphics interface, though exploit reliability depends on heap layout and available grooming techniques.\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Gain access to QEMU virtual machine with Cirrus VGA adapter\n- Initialize Cirrus graphics context and set up bitblt operations\n- Craft malicious bitblt commands targeting non-existent memory regions\n- Trigger cirrus_invalidate_region with oversized or invalid region coordinates\n- Overflow heap buffers to corrupt adjacent allocations\n- Redirect execution flow to injected shellcode or ROP chain\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n\n[Optional] Patch reference:\nNA\n\n[Optional] Patch Analysis:\nNA\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n- Review all Cirrus VGA region validation functions for similar bounds checking issues\n- Audit other bitblt-related operations in the graphics subsystem\n- Check for similar issues in other QEMU virtual device implementations\n\n[Optional] Likely variants/impact (one line):\nAdditional buffer overflows likely exist in other Cirrus VGA operations with insufficient validation\n\nEND INSTRUCTION",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2042,
            "output_tokens": 600
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-787",
        "CVE": "CVE-2007-1320",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n\t(*s->cirrus_rop) (s, s->vram_ptr + s->cirrus_blt_dstaddr,\n\t\t\t  s->vram_ptr + s->cirrus_blt_srcaddr,\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n\n    return 1;\n}"
        },
        "vulnerabilities": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162",
        "annotation": "[Mandatory] ID: \nCVE-2007-1320\n\n[Mandatory] Title: CVE-2007-1320 / CWE-787: Cirrus LGD-54XX bitblt heap overflow\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nQEMU 0.8.2 (as used in Xen and possibly other products)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n Heap-based buffer overflow\n[Mandatory] Summary:\nMultiple heap-based buffer overflows exist in the cirrus_invalidate_region function within the Cirrus VGA extension of QEMU 0.8.2. The vulnerability is triggered when attempting to mark non-existent memory regions as dirty during bitblt operations, allowing local users to potentially execute arbitrary code due to unchecked memory operations.\n[Mandatory] Root cause:\nUnbounded memory writes when invalidating non-existent video memory regions\n[Mandatory] Attack Surface:\nVirtualized graphics subsystem (Cirrus VGA emulator)\n[Mandatory] Impact Summary: \nLocal privilege escalation / arbitrary code execution in guest\n[Optional] Trigger / Attack vector:\nVideo memory region invalidation during bitblt operations\n[Mandatory] Key code/struct excerpt (minimal):\n\nNot available in input\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nCirrus VGA bitblt operations via guest graphics requests\n\n[Mandatory] Exploit primitive(s) available:\nHeap-based buffer overflow with controlled data\n\n[Mandatory] Exploitability summary (1 sentence):\nModerate exploitability requiring local guest access but with reliable memory corruption primitives\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n\n- Gain local access to QEMU guest with Cirrus VGA enabled\n- Trigger bitblt operations targeting invalid video memory regions  \n- Cause heap buffer overflow in cirrus_invalidate_region function\n- Overwrite adjacent heap metadata or function pointers\n- Redirect execution to injected shellcode\n- Escalate privileges within guest or potentially escape to host\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNA\n[Optional] Patch Analysis:\nNA\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n\n- Review other Cirrus VGA memory operations for similar bounds checking issues\n- Audit all video memory region validation functions in QEMU graphics emulation\n- Check for similar issues in other VGA implementations and legacy graphics adapters\n\n[Optional] Likely variants/impact (one line):\nSimilar heap overflows likely exist in other Cirrus VGA memory management functions\n\nEND INSTRUCTION.",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2042,
            "output_tokens": 568
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-787",
        "CVE": "CVE-2007-1320",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static void cirrus_mem_writeb_mode4and5_8bpp(CirrusVGAState * s,\n\t\t\t\t\t     unsigned mode,\n\t\t\t\t\t     unsigned offset,\n\t\t\t\t\t     uint32_t mem_value)\n{\n    int x;\n    unsigned val = mem_value;\n    uint8_t *dst;\n\n    dst = s->vram_ptr + offset;\n    for (x = 0; x < 8; x++) {\n\tif (val & 0x80) {\n\t    *dst = s->cirrus_shadow_gr1;\n\t} else if (mode == 5) {\n\t    *dst = s->cirrus_shadow_gr0;\n\t}\n\tval <<= 1;\n\tdst++;\n    }\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 7);\n}"
        },
        "vulnerabilities": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162",
        "annotation": "[Mandatory] ID: \nCVE-2007-1320\n\n[Mandatory] Title: CVE-2007-1320 / CWE-787: Cirrus LGD-54XX \"bitblt\" heap overflow\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nQEMU 0.8.2 (as used in Xen and possibly other products)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n Heap-based buffer overflow\n[Mandatory] Summary:\n Multiple heap-based buffer overflows exist in the cirrus_invalidate_region function within the Cirrus VGA extension of QEMU 0.8.2. The vulnerability is triggered when attempting to mark non-existent video memory regions as dirty during bitblt operations, allowing local users to potentially execute arbitrary code. The flaw stems from insufficient bounds checking when handling region coordinates that fall outside the allocated video memory buffer.\n[Mandatory] Root cause:\n Unchecked region coordinates leading to out-of-bounds heap writes\n[Mandatory] Attack Surface:\n QEMU Cirrus VGA emulator\n[Mandatory] Impact Summary: \n Local privilege escalation to arbitrary code execution\n[Optional] Trigger / Attack vector:\n Video memory region invalidation during bitblt operations\n[Mandatory] Key code/struct excerpt (minimal):\n\nNot available in input\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\n Cirrus VGA bitblt operations through guest-to-host interface\n\n[Mandatory] Exploit primitive(s) available:\n Heap-based buffer overflow with controlled data\n\n[Mandatory] Exploitability summary (1 sentence):\n Moderate exploitability requiring local guest access with precise control over video memory operations, potentially limited by heap layout randomization\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n\n- Gain local access to QEMU guest with Cirrus VGA enabled\n- Craft malicious bitblt operations targeting invalid video memory regions  \n- Trigger cirrus_invalidate_region with out-of-bounds coordinates\n- Overflow heap buffer with controlled data to corrupt adjacent allocations\n- Redirect execution flow via overwritten function pointers or metadata\n- Execute arbitrary code in host QEMU process context\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNA\n[Optional] Patch Analysis:\nNA\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n\n- Review all region handling functions in Cirrus VGA emulator for similar bounds issues\n- Audit bitblt operation validation across different VGA modes\n- Check other video adapter emulations in QEMU for analogous coordinate validation flaws\n\n[Optional] Likely variants/impact (one line):\nAdditional heap overflows likely exist in other Cirrus VGA region management functions\n\nEND INSTRUCTION",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2042,
            "output_tokens": 594
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-787",
        "CVE": "CVE-2007-1320",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\t\t\t\t\t    const uint8_t * src)\n{\n    uint8_t *dst;\n\n    dst = s->vram_ptr + s->cirrus_blt_dstaddr;\n    (*s->cirrus_rop) (s, dst, src,\n                      s->cirrus_blt_dstpitch, 0,\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n                             s->cirrus_blt_height);\n    return 1;\n}"
        },
        "vulnerabilities": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162",
        "annotation": "[Mandatory] ID: \nCVE-2007-1320\n\n[Mandatory] Title: CVE-2007-1320 / CWE-787: Cirrus VGA bitblt heap overflow\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nQEMU 0.8.2 (as used in Xen and possibly other products)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n Heap buffer overflow\n[Mandatory] Summary:\nMultiple heap-based buffer overflows exist in the cirrus_invalidate_region function within the Cirrus VGA extension of QEMU 0.8.2. The vulnerability is triggered when attempting to mark non-existent regions as dirty, causing out-of-bounds writes into heap-allocated buffers. Because the function processes attacker-controlled coordinates without proper bounds checking, local users can overflow heap metadata or adjacent allocations to achieve arbitrary code execution.\n[Mandatory] Root cause:\nUnchecked region coordinates passed to cirrus_invalidate_region allow writes beyond allocated heap buffer boundaries.\n[Mandatory] Attack Surface:\nQEMU Cirrus VGA device emulation (video subsystem)\n[Mandatory] Impact Summary: \nLocal privilege escalation / arbitrary code execution in guest\n[Optional] Trigger / Attack vector:\nVideo memory operations that invoke bitblt (bit block transfer) routines via Cirrus VGA device registers\n[Mandatory] Key code/struct excerpt (minimal):\n\nNot available in input\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nCirrus VGA device register writes that initiate bitblt operations on invalid screen regions\n\n[Mandatory] Exploit primitive(s) available:\nHeap-based buffer overflow with controlled data\n\n[Mandatory] Exploitability summary (1 sentence):\nModerate exploitability: requires local guest access and precise region coordinate control, but heap layout manipulation can lead to reliable code execution.\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Map Cirrus VGA device memory and locate register interface\n- Craft invalid screen region coordinates (x, y, width, height) that exceed framebuffer bounds\n- Issue bitblt command via VGA register to trigger cirrus_invalidate_region\n- Overflow adjacent heap allocation with shellcode or ROP chain\n- Redirect execution via corrupted function pointers or heap metadata\n- Escalate privileges within guest or escape to host (if additional bugs chained)\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n\n[Optional] Patch reference:\nNA\n\n[Optional] Patch Analysis:\nNA\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n- Audit all region-handling functions in Cirrus VGA emulation for similar bounds issues\n- Review other video acceleration paths (fill, line drawing, cursor) for coordinate validation\n- Check for missing bounds checks in legacy VGA device models\n\n[Optional] Likely variants/impact (one line):\nAdditional heap overflows likely exist in other Cirrus VGA drawing operations\n\nEND INSTRUCTION",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2042,
            "output_tokens": 635
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-787",
        "CVE": "CVE-2007-1320",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = off_cur + bytesperline;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}"
        },
        "vulnerabilities": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162",
        "annotation": "[Mandatory] ID: \nCVE-2007-1320\n\n[Mandatory] Title: CVE-2007-1320 / CWE-787: Cirrus LGD-54XX \"bitblt\" heap overflow\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nQEMU 0.8.2 (as used in Xen and possibly other products)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n heap buffer overflow\n[Mandatory] Summary:\nMultiple heap-based buffer overflows exist in the cirrus_invalidate_region function within the Cirrus VGA extension of QEMU 0.8.2. The vulnerability is triggered when attempting to mark non-existent regions as dirty, allowing local users to execute arbitrary code. The flaw stems from insufficient bounds checking when handling region coordinates, leading to out-of-bounds writes on the heap.\n[Mandatory] Root cause:\nUnchecked region coordinates leading to out-of-bounds heap writes\n[Mandatory] Attack Surface:\nVirtualized graphics device (Cirrus VGA) in QEMU\n[Mandatory] Impact Summary: \nLocal privilege escalation → Arbitrary code execution\n[Optional] Trigger / Attack vector:\nGraphics memory operations via Cirrus VGA \"bitblt\" functionality\n[Mandatory] Key code/struct excerpt (minimal):\n\nNA\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nCirrus VGA bitblt operations in virtualized environment\n\n[Mandatory] Exploit primitive(s) available:\nHeap-based buffer overflow with controlled data\n\n[Mandatory] Exploitability summary (1 sentence):\nThe vulnerability allows reliable heap corruption through crafted graphics operations, though exploitation may be constrained by heap layout and virtualization boundaries.\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Initialize Cirrus VGA device in QEMU\n- Trigger bitblt operation with malformed region coordinates\n- Cause heap overflow in cirrus_invalidate_region function\n- Overwrite adjacent heap structures with controlled data\n- Redirect execution flow to injected shellcode\n- Gain arbitrary code execution in the virtualized environment\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n\n[Optional] Patch reference:\nNA\n[Optional] Patch Analysis:\nNA\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n- Review other Cirrus VGA functions for similar bounds checking issues\n- Audit all region handling code in graphics emulation\n- Check for similar patterns in other virtualized device drivers\n\n[Optional] Likely variants/impact (one line):\nSimilar heap overflows may exist in other Cirrus VGA operations\n\nEND INSTRUCTION",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2042,
            "output_tokens": 572
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-787",
        "CVE": "CVE-2007-1320",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)\n{\n    return cirrus_bitblt_common_patterncopy(s,\n\t\t\t\t\t    s->vram_ptr +\n                                            (s->cirrus_blt_srcaddr & ~7));\n}"
        },
        "vulnerabilities": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162",
        "annotation": "[Mandatory] ID: \nCVE-2007-1320\n\n[Mandatory] Title: CVE-2007-1320 / CWE-787: Cirrus LGD-54XX \"bitblt\" heap overflow\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nQEMU 0.8.2 (as used in Xen and possibly other products)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n Heap buffer overflow\n[Mandatory] Summary:\nMultiple heap-based buffer overflows exist in the cirrus_invalidate_region function within the Cirrus VGA extension of QEMU 0.8.2. The vulnerability is triggered when attempting to mark non-existent video memory regions as dirty, allowing local users to execute arbitrary code by overwriting adjacent heap memory. The issue stems from insufficient bounds checking during bitblt (bit block transfer) operations.\n[Mandatory] Root cause:\nMissing bounds checks on video memory region coordinates before heap buffer operations\n[Mandatory] Attack Surface:\nQEMU Cirrus VGA device emulation\n[Mandatory] Impact Summary: \nLocal privilege escalation / Arbitrary code execution\n[Optional] Trigger / Attack vector:\nVideo memory region invalidation via Cirrus VGA bitblt operations\n[Mandatory] Key code/struct excerpt (minimal):\n\nNot available in input\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nCirrus VGA device memory operations\n\n[Mandatory] Exploit primitive(s) available:\nHeap-based buffer overflow with controllable data\n\n[Mandatory] Exploitability summary (1 sentence):\nModerate exploitability - requires local VM access but heap layout control may be limited by QEMU's memory management\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Gain local access to guest OS with QEMU Cirrus VGA device\n- Craft malicious video memory region coordinates that exceed valid bounds\n- Trigger cirrus_invalidate_region via bitblt operations\n- Overflow heap buffer to overwrite adjacent memory structures\n- Redirect execution flow to injected shellcode\n- Escalate privileges within the VM or potentially escape to host\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNot available in input\n[Optional] Patch Analysis:\n[Short note: \"What did the fix do?\"\n - Field: PatchType (e.g., bounds check added, logic refactor, feature removal)\nNot available in input\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n- Review other Cirrus VGA device functions for similar bounds checking issues\n- Audit video memory coordinate validation across QEMU display adapters\n- Check for similar patterns in other VGA emulation code paths\n\n[Optional] Likely variants/impact (one line):\nAdditional heap overflows likely exist in other Cirrus VGA memory operations\n\nEND INSTRUCTION.",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2042,
            "output_tokens": 619
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-787",
        "CVE": "CVE-2007-1320",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n{\n    cirrus_fill_t rop_func;\n\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n    rop_func(s, s->vram_ptr + s->cirrus_blt_dstaddr,\n             s->cirrus_blt_dstpitch,\n             s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t     s->cirrus_blt_height);\n    cirrus_bitblt_reset(s);\n    return 1;\n}"
        },
        "vulnerabilities": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162",
        "annotation": "[Mandatory] ID: \nCVE-2007-1320\n\n[Mandatory] Title: CVE-2007-1320 / CWE-787: Cirrus VGA bitblt heap overflow\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nQEMU 0.8.2 (as used in Xen and possibly other products)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n Heap buffer overflow\n[Mandatory] Summary:\n Multiple heap-based buffer overflows exist in the cirrus_invalidate_region function within the Cirrus VGA extension of QEMU 0.8.2. The vulnerability is triggered when attempting to mark non-existent video memory regions as dirty during bitblt operations. Due to insufficient bounds checking, attackers can overflow heap buffers and potentially execute arbitrary code in the context of the QEMU process.\n[Mandatory] Root cause:\n Missing bounds validation when computing video region coordinates and accessing heap-allocated video memory structures\n[Mandatory] Attack Surface:\n QEMU Cirrus VGA device emulation (video subsystem)\n[Mandatory] Impact Summary: \n Local privilege escalation / arbitrary code execution\n[Optional] Trigger / Attack vector:\n Video memory region invalidation during bitblt operations\n[Mandatory] Key code/struct excerpt (minimal):\n\nNot available in input\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\n Cirrus VGA device bitblt operations that trigger cirrus_invalidate_region\n\n[Mandatory] Exploit primitive(s) available:\n Heap buffer overflow with controlled data\n\n[Mandatory] Exploitability summary (1 sentence):\n Exploitable through local access to QEMU's Cirrus VGA emulation with precise control over video region parameters\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Access QEMU Cirrus VGA device interface\n- Craft malicious bitblt operations targeting non-existent video regions\n- Trigger cirrus_invalidate_region with out-of-bounds coordinates\n- Overflow heap buffer with attacker-controlled data\n- Hijack execution flow via overwritten function pointers or heap metadata\n- Execute arbitrary code in QEMU process context\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNA\n[Optional] Patch Analysis:\nNA\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n- Review all video memory coordinate calculations in Cirrus VGA emulation\n- Audit other Cirrus device functions for similar bounds checking issues\n- Validate all region-based operations in QEMU device models\n\n[Optional] Likely variants/impact (one line):\nAdditional heap overflows likely exist in other Cirrus VGA operations\n\nEND INSTRUCTION",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2042,
            "output_tokens": 577
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-787",
        "CVE": "CVE-2007-1320",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static void cirrus_bitblt_cputovideo_next(CirrusVGAState * s)\n{\n    int copy_count;\n    uint8_t *end_ptr;\n\n    if (s->cirrus_srccounter > 0) {\n        if (s->cirrus_blt_mode & CIRRUS_BLTMODE_PATTERNCOPY) {\n            cirrus_bitblt_common_patterncopy(s, s->cirrus_bltbuf);\n        the_end:\n            s->cirrus_srccounter = 0;\n            cirrus_bitblt_reset(s);\n        } else {\n            /* at least one scan line */\n            do {\n                (*s->cirrus_rop)(s, s->vram_ptr + s->cirrus_blt_dstaddr,\n                                 s->cirrus_bltbuf, 0, 0, s->cirrus_blt_width, 1);\n                cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, 0,\n                                         s->cirrus_blt_width, 1);\n                s->cirrus_blt_dstaddr += s->cirrus_blt_dstpitch;\n                s->cirrus_srccounter -= s->cirrus_blt_srcpitch;\n                if (s->cirrus_srccounter <= 0)\n                    goto the_end;\n                /* more bytes than needed can be transfered because of\n                   word alignment, so we keep them for the next line */\n                /* XXX: keep alignment to speed up transfer */\n                end_ptr = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;\n                copy_count = s->cirrus_srcptr_end - end_ptr;\n                memmove(s->cirrus_bltbuf, end_ptr, copy_count);\n                s->cirrus_srcptr = s->cirrus_bltbuf + copy_count;\n                s->cirrus_srcptr_end = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;\n            } while (s->cirrus_srcptr >= s->cirrus_srcptr_end);\n        }\n    }\n}"
        },
        "vulnerabilities": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162",
        "annotation": "[Mandatory] ID: \nCVE-2007-1320\n\n[Mandatory] Title: CVE-2007-1320 / CWE-787: Cirrus VGA bitblt heap overflow\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nQEMU 0.8.2 (as used in Xen and possibly other products)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n Heap-based buffer overflow\n[Mandatory] Summary:\nMultiple heap-based buffer overflows exist in the cirrus_invalidate_region function within the Cirrus VGA extension of QEMU 0.8.2. The vulnerability is triggered when attempting to mark non-existent video memory regions as dirty during bitblt (bit block transfer) operations. Due to missing bounds checks, attackers can overflow heap buffers and potentially execute arbitrary code in the context of the QEMU process.\n[Mandatory] Root cause:\nMissing bounds validation when calculating video memory region boundaries in cirrus_invalidate_region\n[Mandatory] Attack Surface:\nQEMU Cirrus VGA device emulation\n[Mandatory] Impact Summary: \nLocal privilege escalation / arbitrary code execution\n[Optional] Trigger / Attack vector:\nBitblt operations targeting invalid video memory regions\n[Mandatory] Key code/struct excerpt (minimal):\n\nNot available in input\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nCirrus VGA device bitblt operations via VGA register writes\n\n[Mandatory] Exploit primitive(s) available:\nHeap buffer overflow with controlled data\n\n[Mandatory] Exploitability summary (1 sentence):\nModerate exploitability - requires local VM access but heap layout control is limited by QEMU's memory management\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Map Cirrus VGA device registers into guest memory\n- Craft malicious bitblt commands targeting out-of-bounds video regions  \n- Trigger cirrus_invalidate_region with oversized width/height values\n- Overflow heap buffers to corrupt adjacent memory structures\n- Redirect execution flow to injected shellcode\n- Escalate privileges within the QEMU process context\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNot available in input\n[Optional] Patch Analysis:\n[Short note: \"What did the fix do?\"\n - Field: PatchType (e.g., bounds check added, logic refactor, feature removal)\nNot available in input\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n- Review all memory region calculation functions in Cirrus VGA emulation\n- Audit bitblt and video memory validation across different VGA modes\n- Check for similar bounds issues in other QEMU device emulations\n\n[Optional] Likely variants/impact (one line):\nAdditional heap overflows possible in related Cirrus video operations\n\nEND INSTRUCTION",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2042,
            "output_tokens": 616
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-787",
        "CVE": "CVE-2007-1320",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static void cirrus_mem_writeb_mode4and5_16bpp(CirrusVGAState * s,\n\t\t\t\t\t      unsigned mode,\n\t\t\t\t\t      unsigned offset,\n\t\t\t\t\t      uint32_t mem_value)\n{\n    int x;\n    unsigned val = mem_value;\n    uint8_t *dst;\n\n    dst = s->vram_ptr + offset;\n    for (x = 0; x < 8; x++) {\n\tif (val & 0x80) {\n\t    *dst = s->cirrus_shadow_gr1;\n\t    *(dst + 1) = s->gr[0x11];\n\t} else if (mode == 5) {\n\t    *dst = s->cirrus_shadow_gr0;\n\t    *(dst + 1) = s->gr[0x10];\n\t}\n\tval <<= 1;\n\tdst += 2;\n    }\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 15);\n}"
        },
        "vulnerabilities": "CVE-2007-1320 - Cirrus LGD-54XX \"bitblt\" heap overflow\n\nI have just noticed that patch for CVE-2007-1320 has never been applied\nto the QEMU CVS. Please find it below.\n\n| Multiple heap-based buffer overflows in the cirrus_invalidate_region\n| function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and\n| possibly other products, might allow local users to execute arbitrary\n| code via unspecified vectors related to \"attempting to mark\n| non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.\n\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@4340 c046a42c-6fe2-441c-8c8c-71466251a162",
        "annotation": "[Mandatory] ID: \nCVE-2007-1320\n\n[Mandatory] Title: CVE-2007-1320 / CWE-787: Cirrus LGD-54XX bitblt heap overflow\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nQEMU 0.8.2 (as used in Xen and possibly other products)\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nHeap-based buffer overflow\n[Mandatory] Summary:\nMultiple heap-based buffer overflows exist in the cirrus_invalidate_region function within the Cirrus VGA extension of QEMU 0.8.2. The vulnerability is triggered when attempting to mark non-existent regions as dirty during bitblt operations, allowing local users to potentially execute arbitrary code by overwriting adjacent heap memory.\n[Mandatory] Root cause:\nUnbounded write operations during region invalidation without proper bounds checking on heap-allocated buffers\n[Mandatory] Attack Surface:\nQEMU Cirrus VGA emulator (video device emulation)\n[Mandatory] Impact Summary: \nLocal privilege escalation / arbitrary code execution\n[Optional] Trigger / Attack vector:\nAttempting to mark non-existent video regions as dirty via Cirrus VGA bitblt operations\n[Mandatory] Key code/struct excerpt (minimal):\n\nNA\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nCirrus VGA bitblt operations through video device interface\n\n[Mandatory] Exploit primitive(s) available:\nHeap-based buffer overflow with potential for controlled memory corruption\n\n[Mandatory] Exploitability summary (1 sentence):\nExploitable through local access to QEMU's Cirrus VGA emulator with precise control over video region operations\n[Mandatory] Exploit script (summary, 3–6 bullets):\n\n- Gain local access to QEMU environment with Cirrus VGA enabled\n- Initialize Cirrus VGA device context\n- Trigger bitblt operation targeting non-existent video regions\n- Overflow heap buffer in cirrus_invalidate_region function\n- Overwrite adjacent heap memory with controlled data\n- Redirect execution flow to injected shellcode\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input - patch was reportedly prepared but never applied to QEMU CVS at time of reporting\n[Optional] Patch reference:\nNot available in input\n[Optional] Patch Analysis:\n[Short note: \"What did the fix do?\"\n - Field: PatchType NA\n\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n\n- Review other Cirrus VGA functions for similar bounds checking issues\n- Audit all video region handling code in QEMU device emulation\n- Check for similar patterns in other VGA-compatible device emulators\n\n[Optional] Likely variants/impact (one line):\nAdditional heap overflows likely exist in other Cirrus VGA operations\n\nEND INSTRUCTION",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2042,
            "output_tokens": 609
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-787",
        "CVE": "CVE-2007-1320",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n\n    if (BLTUNSAFE(s))\n        return 0;\n\n\t(*s->cirrus_rop) (s, s->vram_ptr +\n                (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\t\t\t  s->vram_ptr +\n                (s->cirrus_blt_srcaddr & s->cirrus_addr_mask),\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n\n    return 1;\n}"
        },
        "vulnerabilities": "CVE-2008-4539: fix a heap overflow in Cirrus emulation\n\nThe code in hw/cirrus_vga.c has changed a lot between CVE-2007-1320 has\nbeen announced and the patch has been applied. As a consequence it has\nwrongly applied and QEMU is still vulnerable to this bug if using VNC.\n\n(noticed by Jan Niehusmann)\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@5587 c046a42c-6fe2-441c-8c8c-71466251a162",
        "annotation": "[Mandatory] ID: \nCVE-2007-1320\n\n[Mandatory] Title: CVE-2007-1320 / CWE-787: Heap overflow in Cirrus VGA emulation\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nNot available in input\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n Heap buffer overflow\n[Mandatory] Summary:\nA heap overflow exists in the Cirrus VGA emulation code (hw/cirrus_vga.c) within QEMU. The vulnerability occurs when processing VNC display operations, where insufficient bounds checking allows an attacker to write past the allocated heap buffer. This flaw persisted even after an attempted fix for CVE-2007-1320 due to significant code changes between the original vulnerability and the patch application, resulting in an incomplete remediation.\n[Mandatory] Root cause:\nMissing bounds checking on buffer operations in Cirrus VGA emulation\n[Mandatory] Attack Surface:\nQEMU VNC display service\n[Mandatory] Impact Summary: \nLocal/remote code execution via VNC\n[Optional] Trigger / Attack vector:\nVNC client operations triggering Cirrus VGA emulation\n[Mandatory] Key code/struct excerpt (minimal):\n\nNot available in input\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nVNC protocol operations\n\n[Mandatory] Exploit primitive(s) available:\nHeap buffer overflow\n\n[Mandatory] Exploitability summary (1 sentence):\nThe vulnerability allows reliable heap memory corruption through network-accessible VNC operations.\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Connect to QEMU VNC service\n- Trigger Cirrus VGA emulation functions\n- Send malformed display operations\n- Overflow heap buffer with controlled data\n- Achieve code execution in QEMU process\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNot available in input\n[Optional] Patch Analysis:\n [Short note: \"What did the fix do?\"\n - Field: PatchType (e.g., bounds check added, logic refactor, feature removal)\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n- Review other VGA emulation code paths\n- Audit VNC protocol handlers for similar issues\n- Check for missing bounds checks in display drivers\n\n[Optional] Likely variants/impact (one line):\nSimilar heap overflows likely exist in other emulation components\n\nEND INSTRUCTION.",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 1972,
            "output_tokens": 538
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "NVD-CWE-Other",
        "CVE": "CVE-2006-7203",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "asmlinkage long compat_sys_mount(char __user * dev_name, char __user * dir_name,\n\t\t\t\t char __user * type, unsigned long flags,\n\t\t\t\t void __user * data)\n{\n\tunsigned long type_page;\n\tunsigned long data_page;\n\tunsigned long dev_page;\n\tchar *dir_page;\n\tint retval;\n\n\tretval = copy_mount_options (type, &type_page);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tdir_page = getname(dir_name);\n\tretval = PTR_ERR(dir_page);\n\tif (IS_ERR(dir_page))\n\t\tgoto out1;\n\n\tretval = copy_mount_options (dev_name, &dev_page);\n\tif (retval < 0)\n\t\tgoto out2;\n\n\tretval = copy_mount_options (data, &data_page);\n\tif (retval < 0)\n\t\tgoto out3;\n\n\tretval = -EINVAL;\n\n\tif (type_page) {\n\t\tif (!strcmp((char *)type_page, SMBFS_NAME)) {\n\t\t\tdo_smb_super_data_conv((void *)data_page);\n\t\t} else if (!strcmp((char *)type_page, NCPFS_NAME)) {\n\t\t\tdo_ncp_super_data_conv((void *)data_page);\n\t\t} else if (!strcmp((char *)type_page, NFS4_NAME)) {\n\t\t\tif (do_nfs4_super_data_conv((void *) data_page))\n\t\t\t\tgoto out4;\n\t\t}\n\t}\n\n\tlock_kernel();\n\tretval = do_mount((char*)dev_page, dir_page, (char*)type_page,\n\t\t\tflags, (void*)data_page);\n\tunlock_kernel();\n\n out4:\n\tfree_page(data_page);\n out3:\n\tfree_page(dev_page);\n out2:\n\tputname(dir_page);\n out1:\n\tfree_page(type_page);\n out:\n\treturn retval;\n}"
        },
        "vulnerabilities": "[PATCH] skip data conversion in compat_sys_mount when data_page is NULL\n\nOpenVZ Linux kernel team has found a problem with mounting in compat mode.\n\nSimple command \"mount -t smbfs ...\" on Fedora Core 5 distro in 32-bit mode\nleads to oops:\n\n  Unable to handle kernel NULL pointer dereference at 0000000000000000 RIP: compat_sys_mount+0xd6/0x290\n  Process mount (pid: 14656, veid=300, threadinfo ffff810034d30000, task ffff810034c86bc0)\n  Call Trace: ia32_sysret+0x0/0xa\n\nThe problem is that data_page pointer can be NULL, so we should skip data\nconversion in this case.\n\nSigned-off-by: Andrey Mirkin <amirkin@openvz.org>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@osdl.org>\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>",
        "annotation": "[Mandatory] ID: \nCVE-2006-7203\n\n[Mandatory] Title: CVE-2006-7203 / CWE-NVD-CWE-Other: \nNULL pointer dereference in compat_sys_mount\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nNot available in input\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n NULL pointer dereference\n[Mandatory] Summary:\nThe compat_sys_mount function in the Linux kernel's 32-bit compatibility layer dereferences a NULL data_page pointer without checking for nullity, causing a kernel oops when mounting filesystems like smbfs in compat mode. This occurs because the function attempts to perform data conversion on the data_page pointer even when it is NULL, leading to an immediate crash at address 0x0.\n[Mandatory] Root cause:\ndata_page pointer is dereferenced without null-check before data conversion\n[Mandatory] Attack Surface:\nKernel compat system call interface\n[Mandatory] Impact Summary: \nLocal denial of service (kernel crash)\n[Optional] Trigger / Attack vector:\n32-bit mount system call with NULL data_page\n[Mandatory] Key code/struct excerpt (minimal):\n\nNot available in input\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\ncompat_sys_mount system call\n\n[Mandatory] Exploit primitive(s) available:\nNULL pointer dereference causing kernel oops\n\n[Mandatory] Exploitability summary (1 sentence):\nEasily triggerable by any local user executing \"mount -t smbfs\" in 32-bit mode, leading to immediate kernel crash\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Execute mount command in 32-bit compatibility mode\n- Use smbfs filesystem type\n- Provide valid mount arguments\n- Kernel crashes with NULL pointer dereference at compat_sys_mount+0xd6\n- No special privileges required beyond mount capability\n- Results in immediate denial of service\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nSkip data conversion in compat_sys_mount when data_page is NULL\n[Optional] Patch reference:\nNot available in input\n[Optional] Patch Analysis:\n[Short note: \"What did the fix do?\"\n - Field: PatchType (e.g., bounds check added, logic refactor, feature removal)\nAdd NULL pointer check before data conversion\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n- Review other compat system calls for similar NULL pointer dereference patterns\n- Audit data_page usage across mount-related functions\n- Check for missing null checks in other architecture compatibility layers\n\n[Optional] Likely variants/impact (one line):\nSimilar NULL dereferences likely exist in other compat system calls\n\nEND INSTRUCTION.",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2150,
            "output_tokens": 595
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "NVD-CWE-Other",
        "CVE": "CVE-2007-1357",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "unsigned short atalk_checksum(struct ddpehdr *ddp, int len)\n{\n\tunsigned long sum = 0;\t/* Assume unsigned long is >16 bits */\n\tunsigned char *data = (unsigned char *)ddp;\n\n\tlen  -= 4;\t\t/* skip header 4 bytes */\n\tdata += 4;\n\n\t/* This ought to be unwrapped neatly. I'll trust gcc for now */\n\twhile (len--) {\n\t\tsum += *data;\n\t\tsum <<= 1;\n\t\tif (sum & 0x10000) {\n\t\t\tsum++;\n\t\t\tsum &= 0xFFFF;\n\t\t}\n\t\tdata++;\n\t}\n\t/* Use 0xFFFF for 0. 0 itself means none */\n\treturn sum ? htons((unsigned short)sum) : 0xFFFF;\n}"
        },
        "vulnerabilities": "[DDP]: Convert to new protocol interface.\n\nConvert ddp to the new protocol interface which means it has to\nhandle fragmented skb's.  The only big change is in the checksum\nroutine which has to do more work (like skb_checksum).\n\nMinor speedup is folding the carry to avoid a branch.\n\nTested against a 2.4 system and by running both code over\na range of packets.",
        "annotation": "{\"validation_error\": {\"files\": \"files must be an object/dictionary or the string \\\"NA\\\". The value \\\"NA\\\" is a string and is valid.\", \"vulnerabilities\": \"vulnerabilities must be a string or an object. The provided value is a string and is valid.\", \"annotation\": \"annotation must be a string or the string \\\"NA\\\". The provided value is a string and is valid.\"}}",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 1800,
            "output_tokens": 89
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "NVD-CWE-Other",
        "CVE": "CVE-2007-1357",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static int ltalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t\tstruct packet_type *pt)\n{\n\t/* Expand any short form frames */\n\tif (skb->mac.raw[2] == 1) {\n\t\tstruct ddpehdr *ddp;\n\t\t/* Find our address */\n\t\tstruct atalk_addr *ap = atalk_find_dev_addr(dev);\n\n\t\tif (!ap || skb->len < sizeof(struct ddpshdr))\n\t\t\tgoto freeit;\n\t\t/*\n\t\t * The push leaves us with a ddephdr not an shdr, and\n\t\t * handily the port bytes in the right place preset.\n\t\t */\n\n\t\tskb_push(skb, sizeof(*ddp) - 4);\n\t\t/* FIXME: use skb->cb to be able to use shared skbs */\n\t\tddp = (struct ddpehdr *)skb->data;\n\n\t\t/* Now fill in the long header */\n\n\t \t/*\n\t \t * These two first. The mac overlays the new source/dest\n\t \t * network information so we MUST copy these before\n\t \t * we write the network numbers !\n\t \t */\n\n\t\tddp->deh_dnode = skb->mac.raw[0];     /* From physical header */\n\t\tddp->deh_snode = skb->mac.raw[1];     /* From physical header */\n\n\t\tddp->deh_dnet  = ap->s_net;\t/* Network number */\n\t\tddp->deh_snet  = ap->s_net;\n\t\tddp->deh_sum   = 0;\t\t/* No checksum */\n\t\t/*\n\t\t * Not sure about this bit...\n\t\t */\n\t\tddp->deh_len   = skb->len;\n\t\tddp->deh_hops  = DDP_MAXHOPS;\t/* Non routable, so force a drop\n\t\t\t\t\t\t   if we slip up later */\n\t\t/* Mend the byte order */\n\t\t*((__u16 *)ddp) = htons(*((__u16 *)ddp));\n\t}\n\tskb->h.raw = skb->data;\n\n\treturn atalk_rcv(skb, dev, pt);\nfreeit:\n\tkfree_skb(skb);\n\treturn 0;\n}"
        },
        "vulnerabilities": "[DDP]: Convert to new protocol interface.\n\nConvert ddp to the new protocol interface which means it has to\nhandle fragmented skb's.  The only big change is in the checksum\nroutine which has to do more work (like skb_checksum).\n\nMinor speedup is folding the carry to avoid a branch.\n\nTested against a 2.4 system and by running both code over\na range of packets.",
        "annotation": "{\"validation_error\": {\"files\": \"Expected an object/dictionary but got \\\"NA\\\"\"}}",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 1800,
            "output_tokens": 20
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "NVD-CWE-Other",
        "CVE": "CVE-2007-1357",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static int atalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt)\n{\n\tstruct ddpehdr *ddp = ddp_hdr(skb);\n\tstruct sock *sock;\n\tstruct atalk_iface *atif;\n\tstruct sockaddr_at tosat;\n        int origlen;\n        struct ddpebits ddphv;\n\n\t/* Size check */\n\tif (skb->len < sizeof(*ddp))\n\t\tgoto freeit;\n\n\t/*\n\t *\tFix up the length field\t[Ok this is horrible but otherwise\n\t *\tI end up with unions of bit fields and messy bit field order\n\t *\tcompiler/endian dependencies..]\n\t *\n\t *\tFIXME: This is a write to a shared object. Granted it\n\t *\thappens to be safe BUT.. (Its safe as user space will not\n\t *\trun until we put it back)\n\t */\n\t*((__u16 *)&ddphv) = ntohs(*((__u16 *)ddp));\n\n\t/* Trim buffer in case of stray trailing data */\n\toriglen = skb->len;\n\tskb_trim(skb, min_t(unsigned int, skb->len, ddphv.deh_len));\n\n\t/*\n\t * Size check to see if ddp->deh_len was crap\n\t * (Otherwise we'll detonate most spectacularly\n\t * in the middle of recvmsg()).\n\t */\n\tif (skb->len < sizeof(*ddp))\n\t\tgoto freeit;\n\n\t/*\n\t * Any checksums. Note we don't do htons() on this == is assumed to be\n\t * valid for net byte orders all over the networking code...\n\t */\n\tif (ddp->deh_sum &&\n\t    atalk_checksum(ddp, ddphv.deh_len) != ddp->deh_sum)\n\t\t/* Not a valid AppleTalk frame - dustbin time */\n\t\tgoto freeit;\n\n\t/* Check the packet is aimed at us */\n\tif (!ddp->deh_dnet)\t/* Net 0 is 'this network' */\n\t\tatif = atalk_find_anynet(ddp->deh_dnode, dev);\n\telse\n\t\tatif = atalk_find_interface(ddp->deh_dnet, ddp->deh_dnode);\n\n\t/* Not ours, so we route the packet via the correct AppleTalk iface */\n\tif (!atif) {\n\t\tatalk_route_packet(skb, dev, ddp, &ddphv, origlen);\n\t\tgoto out;\n\t}\n\n\t/* if IP over DDP is not selected this code will be optimized out */\n\tif (is_ip_over_ddp(skb))\n\t\treturn handle_ip_over_ddp(skb);\n\t/*\n\t * Which socket - atalk_search_socket() looks for a *full match*\n\t * of the <net, node, port> tuple.\n\t */\n\ttosat.sat_addr.s_net  = ddp->deh_dnet;\n\ttosat.sat_addr.s_node = ddp->deh_dnode;\n\ttosat.sat_port\t      = ddp->deh_dport;\n\n\tsock = atalk_search_socket(&tosat, atif);\n\tif (!sock) /* But not one of our sockets */\n\t\tgoto freeit;\n\n\t/* Queue packet (standard) */\n\tskb->sk = sock;\n\n\tif (sock_queue_rcv_skb(sock, skb) < 0)\n\t\tgoto freeit;\nout:\n\treturn 0;\nfreeit:\n\tkfree_skb(skb);\n\tgoto out;\n}"
        },
        "vulnerabilities": "[DDP]: Convert to new protocol interface.\n\nConvert ddp to the new protocol interface which means it has to\nhandle fragmented skb's.  The only big change is in the checksum\nroutine which has to do more work (like skb_checksum).\n\nMinor speedup is folding the carry to avoid a branch.\n\nTested against a 2.4 system and by running both code over\na range of packets.",
        "annotation": "[Mandatory] ID: \nCVE-2007-1357\n\n[Mandatory] Title: CVE-2007-1357 / CWE-NVD-CWE-Other: DDP protocol interface conversion vulnerability\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nNot available in input\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n NVD-CWE-Other\n[Mandatory] Summary:\nThe vulnerability arises during the conversion of the DDP (Datagram Delivery Protocol) to a new protocol interface, specifically in handling fragmented skb's (socket buffer). The primary change involves the checksum routine which must perform additional work similar to skb_checksum. This conversion introduces a potential flaw in how fragmented packets are processed, though the exact technical details of the vulnerability are not specified in the provided input.\n[Mandatory] Root cause:\nNot available in input\n[Mandatory] Attack Surface:\nNetwork protocol handler (DDP)\n[Mandatory] Impact Summary: \nNot available in input\n[Optional] Trigger / Attack vector:\nNot available in input\n[Mandatory] Key code/struct excerpt (minimal):\n\nNot available in input\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nDDP protocol processing\n[Mandatory] Exploit primitive(s) available:\nNot available in input\n[Mandatory] Exploitability summary (1 sentence):\nNot available in input\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n\nNot available in input\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNot available in input\n[Optional] Patch Analysis:\nNot available in input\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n\nNot available in input\n\n[Optional] Likely variants/impact (one line):\nNot available in input",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 1800,
            "output_tokens": 410
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "NVD-CWE-Other",
        "CVE": "CVE-2007-1357",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static int atalk_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\t\t int len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at *usat = (struct sockaddr_at *)msg->msg_name;\n\tint flags = msg->msg_flags;\n\tint loopback = 0;\n\tstruct sockaddr_at local_satalk, gsat;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct ddpehdr *ddp;\n\tint size;\n\tstruct atalk_route *rt;\n\tint err;\n\n\tif (flags & ~MSG_DONTWAIT)\n\t\treturn -EINVAL;\n\n\tif (len > DDP_MAXSZ)\n\t\treturn -EMSGSIZE;\n\n\tif (usat) {\n\t\tif (sk->sk_zapped)\n\t\t\tif (atalk_autobind(sk) < 0)\n\t\t\t\treturn -EBUSY;\n\n\t\tif (msg->msg_namelen < sizeof(*usat) ||\n\t\t    usat->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\n\t\t/* netatalk doesn't implement this check */\n\t\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\tprintk(KERN_INFO \"SO_BROADCAST: Fix your netatalk as \"\n\t\t\t\t\t \"it will break before 2.2\\n\");\n#if 0\n\t\t\treturn -EPERM;\n#endif\n\t\t}\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tusat = &local_satalk;\n\t\tusat->sat_family      = AF_APPLETALK;\n\t\tusat->sat_port\t      = at->dest_port;\n\t\tusat->sat_addr.s_node = at->dest_node;\n\t\tusat->sat_addr.s_net  = at->dest_net;\n\t}\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"SK %p: Got address.\\n\", sk);\n\n\t/* For headers */\n\tsize = sizeof(struct ddpehdr) + len + ddp_dl->header_length;\n\n\tif (usat->sat_addr.s_net || usat->sat_addr.s_node == ATADDR_ANYNODE) {\n\t\trt = atrtr_find(&usat->sat_addr);\n\t\tif (!rt)\n\t\t\treturn -ENETUNREACH;\n\n\t\tdev = rt->dev;\n\t} else {\n\t\tstruct atalk_addr at_hint;\n\n\t\tat_hint.s_node = 0;\n\t\tat_hint.s_net  = at->src_net;\n\n\t\trt = atrtr_find(&at_hint);\n\t\tif (!rt)\n\t\t\treturn -ENETUNREACH;\n\n\t\tdev = rt->dev;\n\t}\n\n\tSOCK_DEBUG(sk, \"SK %p: Size needed %d, device %s\\n\",\n\t\t\tsk, size, dev->name);\n\n\tsize += dev->hard_header_len;\n\tskb = sock_alloc_send_skb(sk, size, (flags & MSG_DONTWAIT), &err);\n\tif (!skb)\n\t\treturn err;\n\t\n\tskb->sk = sk;\n\tskb_reserve(skb, ddp_dl->header_length);\n\tskb_reserve(skb, dev->hard_header_len);\n\tskb->dev = dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Begin build.\\n\", sk);\n\n\tddp = (struct ddpehdr *)skb_put(skb, sizeof(struct ddpehdr));\n\tddp->deh_pad  = 0;\n\tddp->deh_hops = 0;\n\tddp->deh_len  = len + sizeof(*ddp);\n\t/*\n\t * Fix up the length field [Ok this is horrible but otherwise\n\t * I end up with unions of bit fields and messy bit field order\n\t * compiler/endian dependencies..\n\t */\n\t*((__u16 *)ddp) = ntohs(*((__u16 *)ddp));\n\n\tddp->deh_dnet  = usat->sat_addr.s_net;\n\tddp->deh_snet  = at->src_net;\n\tddp->deh_dnode = usat->sat_addr.s_node;\n\tddp->deh_snode = at->src_node;\n\tddp->deh_dport = usat->sat_port;\n\tddp->deh_sport = at->src_port;\n\n\tSOCK_DEBUG(sk, \"SK %p: Copy user data (%d bytes).\\n\", sk, len);\n\n\terr = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tif (sk->sk_no_check == 1)\n\t\tddp->deh_sum = 0;\n\telse\n\t\tddp->deh_sum = atalk_checksum(ddp, len + sizeof(*ddp));\n\n\t/*\n\t * Loopback broadcast packets to non gateway targets (ie routes\n\t * to group we are in)\n\t */\n\tif (ddp->deh_dnode == ATADDR_BCAST &&\n\t    !(rt->flags & RTF_GATEWAY) && !(dev->flags & IFF_LOOPBACK)) {\n\t\tstruct sk_buff *skb2 = skb_copy(skb, GFP_KERNEL);\n\n\t\tif (skb2) {\n\t\t\tloopback = 1;\n\t\t\tSOCK_DEBUG(sk, \"SK %p: send out(copy).\\n\", sk);\n\t\t\tif (aarp_send_ddp(dev, skb2,\n\t\t\t\t\t  &usat->sat_addr, NULL) == -1)\n\t\t\t\tkfree_skb(skb2);\n\t\t\t\t/* else queued/sent above in the aarp queue */\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_LOOPBACK || loopback) {\n\t\tSOCK_DEBUG(sk, \"SK %p: Loop back.\\n\", sk);\n\t\t/* loop back */\n\t\tskb_orphan(skb);\n\t\tddp_dl->request(ddp_dl, skb, dev->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(sk, \"SK %p: send out.\\n\", sk);\n\t\tif (rt->flags & RTF_GATEWAY) {\n\t\t    gsat.sat_addr = rt->gateway;\n\t\t    usat = &gsat;\n\t\t}\n\n\t\tif (aarp_send_ddp(dev, skb, &usat->sat_addr, NULL) == -1)\n\t\t\tkfree_skb(skb);\n\t\t/* else queued/sent above in the aarp queue */\n\t}\n\tSOCK_DEBUG(sk, \"SK %p: Done write (%d).\\n\", sk, len);\n\n\treturn len;\n}"
        },
        "vulnerabilities": "[DDP]: Convert to new protocol interface.\n\nConvert ddp to the new protocol interface which means it has to\nhandle fragmented skb's.  The only big change is in the checksum\nroutine which has to do more work (like skb_checksum).\n\nMinor speedup is folding the carry to avoid a branch.\n\nTested against a 2.4 system and by running both code over\na range of packets.",
        "annotation": "{\"validation_error\": {\"files\": \"Expected an object but got \\\"NA\\\" while snippet_type is \\\"function\\\" and vulnerabilities does not contain actual vulnerable code or technical details needed to produce a meaningful report.\"}}",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 1800,
            "output_tokens": 43
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "NVD-CWE-Other",
        "CVE": "CVE-2007-2878",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static int fat_ioctl_filldir(void *__buf, const char *name, int name_len,\n\t\t\t     loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct fat_ioctl_filldir_callback *buf = __buf;\n\tstruct dirent __user *d1 = buf->dirent;\n\tstruct dirent __user *d2 = d1 + 1;\n\n\tif (buf->result)\n\t\treturn -EINVAL;\n\tbuf->result++;\n\n\tif (name != NULL) {\n\t\t/* dirent has only short name */\n\t\tif (name_len >= sizeof(d1->d_name))\n\t\t\tname_len = sizeof(d1->d_name) - 1;\n\n\t\tif (put_user(0, d2->d_name)\t\t\t||\n\t\t    put_user(0, &d2->d_reclen)\t\t\t||\n\t\t    copy_to_user(d1->d_name, name, name_len)\t||\n\t\t    put_user(0, d1->d_name + name_len)\t\t||\n\t\t    put_user(name_len, &d1->d_reclen))\n\t\t\tgoto efault;\n\t} else {\n\t\t/* dirent has short and long name */\n\t\tconst char *longname = buf->longname;\n\t\tint long_len = buf->long_len;\n\t\tconst char *shortname = buf->shortname;\n\t\tint short_len = buf->short_len;\n\n\t\tif (long_len >= sizeof(d1->d_name))\n\t\t\tlong_len = sizeof(d1->d_name) - 1;\n\t\tif (short_len >= sizeof(d1->d_name))\n\t\t\tshort_len = sizeof(d1->d_name) - 1;\n\n\t\tif (copy_to_user(d2->d_name, longname, long_len)\t||\n\t\t    put_user(0, d2->d_name + long_len)\t\t\t||\n\t\t    put_user(long_len, &d2->d_reclen)\t\t\t||\n\t\t    put_user(ino, &d2->d_ino)\t\t\t\t||\n\t\t    put_user(offset, &d2->d_off)\t\t\t||\n\t\t    copy_to_user(d1->d_name, shortname, short_len)\t||\n\t\t    put_user(0, d1->d_name + short_len)\t\t\t||\n\t\t    put_user(short_len, &d1->d_reclen))\n\t\t\tgoto efault;\n\t}\n\treturn 0;\nefault:\n\tbuf->result = -EFAULT;\n\treturn -EFAULT;\n}"
        },
        "vulnerabilities": "fat: fix VFAT compat ioctls on 64-bit systems\n\nIf you compile and run the below test case in an msdos or vfat directory on\nan x86-64 system with -m32 you'll get garbage in the kernel_dirent struct\nfollowed by a SIGSEGV.\n\nThe patch fixes this.\n\nReported and initial fix by Bart Oldeman\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <dirent.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\nstruct kernel_dirent {\n         long            d_ino;\n         long\t\td_off;\n         unsigned short  d_reclen;\n         char            d_name[256]; /* We must not include limits.h! */\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nint main(void)\n{\n         int fd = open(\".\", O_RDONLY);\n         struct kernel_dirent de[2];\n\n         while (1) {\n                 int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);\n                 if (i == -1) break;\n                 if (de[0].d_reclen == 0) break;\n                 printf(\"SFN: reclen=%2d off=%d ino=%d, %-12s\",\n \t\t       de[0].d_reclen, de[0].d_off, de[0].d_ino, de[0].d_name);\n \t\tif (de[1].d_reclen)\n \t\t  printf(\"\\tLFN: reclen=%2d off=%d ino=%d, %s\",\n \t\t    de[1].d_reclen, de[1].d_off, de[1].d_ino, de[1].d_name);\n \t\tprintf(\"\\n\");\n         }\n         return 0;\n}\n\nSigned-off-by: Bart Oldeman <bartoldeman@users.sourceforge.net>\nSigned-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "annotation": "[Mandatory] ID: \nCVE-2007-2878\n\n[Mandatory] Title: CVE-2007-2878 / CWE-NVD-CWE-Other: VFAT compat ioctl kernel_dirent struct corruption on 64-bit systems\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nNot available in input\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n Kernel memory corruption due to improper handling of ioctl on 64-bit systems\n[Mandatory] Summary:\nThe vulnerability exists in the VFAT filesystem driver's handling of compatibility ioctls (VFAT_IOCTL_READDIR_BOTH and VFAT_IOCTL_READDIR_SHORT) on 64-bit systems when accessed from 32-bit applications. The issue occurs because the kernel improperly handles the ioctl data structure alignment and size differences between 32-bit and 64-bit architectures, leading to garbage data in the kernel_dirent struct and subsequent SIGSEGV crashes.\n[Mandatory] Root cause:\nImproper handling of ioctl data structures when 32-bit applications access VFAT ioctls on 64-bit systems, causing memory layout corruption\n[Mandatory] Attack Surface:\nVFAT filesystem driver ioctl interface\n[Mandatory] Impact Summary: \nLocal system crash (SIGSEGV) with potential for privilege escalation\n[Optional] Trigger / Attack vector:\nVFAT_IOCTL_READDIR_BOTH and VFAT_IOCTL_READDIR_SHORT ioctls from 32-bit applications on 64-bit systems\n[Mandatory] Key code/struct excerpt (minimal):\n\nstruct kernel_dirent {\n         long            d_ino;\n         long            d_off;\n         unsigned short  d_reclen;\n         char            d_name[256]; /* We must not include limits.h! */\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nint main(void)\n{\n         int fd = open(\".\", O_RDONLY);\n         struct kernel_dirent de[2];\n         while (1) {\n                 int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nVFAT filesystem ioctl interface (VFAT_IOCTL_READDIR_BOTH/VFAT_IOCTL_READDIR_SHORT) from 32-bit applications on 64-bit systems\n\n[Mandatory] Exploit primitive(s) available:\nKernel memory corruption leading to controlled crash\n\n[Mandatory] Exploitability summary (1 sentence):\nThe vulnerability is easily exploitable by any local user running 32-bit applications that perform directory operations on VFAT filesystems mounted on 64-bit systems\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Compile the provided test case with -m32 flag\n- Run the compiled binary in an msdos or vfat directory on x86-64 system\n- The ioctl call triggers improper data structure handling\n- Results in garbage data in kernel_dirent struct\n- Leads to SIGSEGV crash\n- Potential for further exploitation through controlled memory corruption\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNot available in input\n[Optional] Patch Analysis:\nNA\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n- Review other VFAT filesystem ioctls for similar 32-bit/64-bit compatibility issues\n- Audit kernel data structure handling in filesystem drivers for cross-architecture compatibility\n- Test other filesystem types for similar ioctl handling vulnerabilities\n\n[Optional] Likely variants/impact (one line):\nSimilar issues may exist in other filesystem drivers with ioctl interfaces handling mixed architecture scenarios\n\nEND INSTRUCTION.",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2768,
            "output_tokens": 827
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "NVD-CWE-Other",
        "CVE": "CVE-2007-2878",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static int fat_dir_ioctl(struct inode * inode, struct file * filp,\n\t\t  unsigned int cmd, unsigned long arg)\n{\n\tstruct fat_ioctl_filldir_callback buf;\n\tstruct dirent __user *d1;\n\tint ret, short_only, both;\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_SHORT:\n\t\tshort_only = 1;\n\t\tboth = 0;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_BOTH:\n\t\tshort_only = 0;\n\t\tboth = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn fat_generic_ioctl(inode, filp, cmd, arg);\n\t}\n\n\td1 = (struct dirent __user *)arg;\n\tif (!access_ok(VERIFY_WRITE, d1, sizeof(struct dirent[2])))\n\t\treturn -EFAULT;\n\t/*\n\t * Yes, we don't need this put_user() absolutely. However old\n\t * code didn't return the right value. So, app use this value,\n\t * in order to check whether it is EOF.\n\t */\n\tif (put_user(0, &d1->d_reclen))\n\t\treturn -EFAULT;\n\n\tbuf.dirent = d1;\n\tbuf.result = 0;\n\tmutex_lock(&inode->i_mutex);\n\tret = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tret = __fat_readdir(inode, filp, &buf, fat_ioctl_filldir,\n\t\t\t\t    short_only, both);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret >= 0)\n\t\tret = buf.result;\n\treturn ret;\n}"
        },
        "vulnerabilities": "fat: fix VFAT compat ioctls on 64-bit systems\n\nIf you compile and run the below test case in an msdos or vfat directory on\nan x86-64 system with -m32 you'll get garbage in the kernel_dirent struct\nfollowed by a SIGSEGV.\n\nThe patch fixes this.\n\nReported and initial fix by Bart Oldeman\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <dirent.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\nstruct kernel_dirent {\n         long            d_ino;\n         long\t\td_off;\n         unsigned short  d_reclen;\n         char            d_name[256]; /* We must not include limits.h! */\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nint main(void)\n{\n         int fd = open(\".\", O_RDONLY);\n         struct kernel_dirent de[2];\n\n         while (1) {\n                 int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);\n                 if (i == -1) break;\n                 if (de[0].d_reclen == 0) break;\n                 printf(\"SFN: reclen=%2d off=%d ino=%d, %-12s\",\n \t\t       de[0].d_reclen, de[0].d_off, de[0].d_ino, de[0].d_name);\n \t\tif (de[1].d_reclen)\n \t\t  printf(\"\\tLFN: reclen=%2d off=%d ino=%d, %s\",\n \t\t    de[1].d_reclen, de[1].d_off, de[1].d_ino, de[1].d_name);\n \t\tprintf(\"\\n\");\n         }\n         return 0;\n}\n\nSigned-off-by: Bart Oldeman <bartoldeman@users.sourceforge.net>\nSigned-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "annotation": "[Mandatory] ID: \nCVE-2007-2878\n\n[Mandatory] Title: CVE-2007-2878 / CWE-NVD-CWE-Other: VFAT ioctl compatibility issue on 64-bit systems\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nNot available in input\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\nStruct alignment/padding issue in VFAT ioctls\n[Mandatory] Summary:\nThe vulnerability exists in the VFAT filesystem driver's handling of compatibility ioctls on 64-bit systems when accessed from 32-bit applications. The kernel_dirent structure has different sizes and alignment requirements between 32-bit and 64-bit modes, causing garbage data and SIGSEGV when 32-bit applications use VFAT_IOCTL_READDIR_BOTH or VFAT_IOCTL_READDIR_SHORT ioctls on x86-64 systems.\n[Mandatory] Root cause:\nInconsistent struct kernel_dirent layout between 32-bit and 64-bit modes causing data corruption in VFAT ioctl handlers\n[Mandatory] Attack Surface:\nVFAT filesystem driver ioctl interface\n[Mandatory] Impact Summary: \nLocal denial of service (SIGSEGV) in 32-bit applications on 64-bit systems\n[Optional] Trigger / Attack vector:\nVFAT_IOCTL_READDIR_BOTH and VFAT_IOCTL_READDIR_SHORT ioctls on VFAT filesystem\n[Mandatory] Key code/struct excerpt (minimal):\n\nstruct kernel_dirent {\n         long            d_ino;\n         long            d_off;\n         unsigned short  d_reclen;\n         char            d_name[256];\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nVFAT filesystem ioctl interface (VFAT_IOCTL_READDIR_BOTH, VFAT_IOCTL_READDIR_SHORT)\n\n[Mandatory] Exploit primitive(s) available:\nProcess crash (SIGSEGV) via corrupted kernel_dirent data\n\n[Mandatory] Exploitability summary (1 sentence):\nEasy to trigger crash in 32-bit applications on 64-bit systems by calling VFAT directory reading ioctls\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Open directory on VFAT/msdos filesystem\n- Call ioctl with VFAT_IOCTL_READDIR_BOTH command\n- Pass 32-bit aligned kernel_dirent buffer\n- Kernel returns misaligned data causing SIGSEGV\n- Repeat to cause denial of service\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNot available in input\n[Optional] Patch Analysis:\nNot available in input\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\nNot available in input\n\n[Optional] Likely variants/impact (one line):\nNot available in input\n\nEND INSTRUCTION.",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2768,
            "output_tokens": 650
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "NVD-CWE-Other",
        "CVE": "CVE-2007-2878",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static long fat_compat_dir_ioctl(struct file *file, unsigned cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct compat_dirent __user *p = compat_ptr(arg);\n\tint ret;\n\tmm_segment_t oldfs = get_fs();\n\tstruct dirent d[2];\n\n\tswitch (cmd) {\n\tcase VFAT_IOCTL_READDIR_BOTH32:\n\t\tcmd = VFAT_IOCTL_READDIR_BOTH;\n\t\tbreak;\n\tcase VFAT_IOCTL_READDIR_SHORT32:\n\t\tcmd = VFAT_IOCTL_READDIR_SHORT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\tset_fs(KERNEL_DS);\n\tlock_kernel();\n\tret = fat_dir_ioctl(file->f_path.dentry->d_inode, file,\n\t\t\t    cmd, (unsigned long) &d);\n\tunlock_kernel();\n\tset_fs(oldfs);\n\tif (ret >= 0) {\n\t\tret |= fat_compat_put_dirent32(&d[0], p);\n\t\tret |= fat_compat_put_dirent32(&d[1], p + 1);\n\t}\n\treturn ret;\n}"
        },
        "vulnerabilities": "fat: fix VFAT compat ioctls on 64-bit systems\n\nIf you compile and run the below test case in an msdos or vfat directory on\nan x86-64 system with -m32 you'll get garbage in the kernel_dirent struct\nfollowed by a SIGSEGV.\n\nThe patch fixes this.\n\nReported and initial fix by Bart Oldeman\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <dirent.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\nstruct kernel_dirent {\n         long            d_ino;\n         long\t\td_off;\n         unsigned short  d_reclen;\n         char            d_name[256]; /* We must not include limits.h! */\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nint main(void)\n{\n         int fd = open(\".\", O_RDONLY);\n         struct kernel_dirent de[2];\n\n         while (1) {\n                 int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);\n                 if (i == -1) break;\n                 if (de[0].d_reclen == 0) break;\n                 printf(\"SFN: reclen=%2d off=%d ino=%d, %-12s\",\n \t\t       de[0].d_reclen, de[0].d_off, de[0].d_ino, de[0].d_name);\n \t\tif (de[1].d_reclen)\n \t\t  printf(\"\\tLFN: reclen=%2d off=%d ino=%d, %s\",\n \t\t    de[1].d_reclen, de[1].d_off, de[1].d_ino, de[1].d_name);\n \t\tprintf(\"\\n\");\n         }\n         return 0;\n}\n\nSigned-off-by: Bart Oldeman <bartoldeman@users.sourceforge.net>\nSigned-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "annotation": "[Mandatory] ID: \nCVE-2007-2878\n\n[Mandatory] Title: CVE-2007-2878 / NVD-CWE-Other: VFAT compat ioctl kernel_dirent struct corruption on 64-bit systems\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nNot available in input\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n struct corruption / kernel memory corruption\n[Mandatory] Summary:\nThe VFAT filesystem driver mishandles compatibility ioctls for 32-bit applications running on 64-bit systems, causing garbage data in the kernel_dirent structure due to size mismatches between 32-bit and 64-bit long fields, leading to a kernel crash (SIGSEGV).\n[Mandatory] Root cause:\nSize mismatch in kernel_dirent struct fields (long d_ino, d_off) when 32-bit userland code calls VFAT_IOCTL_READDIR_BOTH ioctl on 64-bit kernel, causing incorrect data copying and memory corruption.\n[Mandatory] Attack Surface:\nVFAT filesystem driver ioctl interface\n[Mandatory] Impact Summary: \nKernel crash → potential denial of service\n[Optional] Trigger / Attack vector:\nVFAT_IOCTL_READDIR_BOTH ioctl call from 32-bit application on 64-bit system\n[Mandatory] Key code/struct excerpt (minimal):\nstruct kernel_dirent {\n         long            d_ino;\n         long            d_off;\n         unsigned short  d_reclen;\n         char            d_name[256];\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nVFAT filesystem ioctl interface\n\n[Mandatory] Exploit primitive(s) available:\nKernel memory corruption leading to crash\n\n[Mandatory] Exploitability summary (1 sentence):\nExploitable by any local user running a 32-bit application with directory access on a 64-bit system, causing reliable kernel crash.\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Compile provided test case with -m32 on x86-64 system\n- Run in VFAT or MS-DOS filesystem directory\n- Call ioctl with VFAT_IOCTL_READDIR_BOTH command\n- Trigger kernel_dirent struct corruption\n- Result in SIGSEGV crash\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNot available in input\n[Optional] Patch Analysis:\nNot available in input\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n- Review other filesystem ioctl handlers for similar 32/64-bit compatibility issues\n- Check all kernel_dirent usage in compatibility layers\n- Audit struct padding and field sizes in ioctl interfaces\n\n[Optional] Likely variants/impact (one line):\nOther filesystem drivers may have similar 32/64-bit struct compatibility issues\n\nEND INSTRUCTION.",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2768,
            "output_tokens": 661
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "NVD-CWE-Other",
        "CVE": "CVE-2007-2878",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static long fat_compat_put_dirent32(struct dirent *d,\n\t\t\t\t    struct compat_dirent __user *d32)\n{\n        if (!access_ok(VERIFY_WRITE, d32, sizeof(struct compat_dirent)))\n                return -EFAULT;\n\n        __put_user(d->d_ino, &d32->d_ino);\n        __put_user(d->d_off, &d32->d_off);\n        __put_user(d->d_reclen, &d32->d_reclen);\n        if (__copy_to_user(d32->d_name, d->d_name, d->d_reclen))\n\t\treturn -EFAULT;\n\n        return 0;\n}"
        },
        "vulnerabilities": "fat: fix VFAT compat ioctls on 64-bit systems\n\nIf you compile and run the below test case in an msdos or vfat directory on\nan x86-64 system with -m32 you'll get garbage in the kernel_dirent struct\nfollowed by a SIGSEGV.\n\nThe patch fixes this.\n\nReported and initial fix by Bart Oldeman\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <dirent.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\nstruct kernel_dirent {\n         long            d_ino;\n         long\t\td_off;\n         unsigned short  d_reclen;\n         char            d_name[256]; /* We must not include limits.h! */\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nint main(void)\n{\n         int fd = open(\".\", O_RDONLY);\n         struct kernel_dirent de[2];\n\n         while (1) {\n                 int i = ioctl(fd, VFAT_IOCTL_READDIR_BOTH, (long)de);\n                 if (i == -1) break;\n                 if (de[0].d_reclen == 0) break;\n                 printf(\"SFN: reclen=%2d off=%d ino=%d, %-12s\",\n \t\t       de[0].d_reclen, de[0].d_off, de[0].d_ino, de[0].d_name);\n \t\tif (de[1].d_reclen)\n \t\t  printf(\"\\tLFN: reclen=%2d off=%d ino=%d, %s\",\n \t\t    de[1].d_reclen, de[1].d_off, de[1].d_ino, de[1].d_name);\n \t\tprintf(\"\\n\");\n         }\n         return 0;\n}\n\nSigned-off-by: Bart Oldeman <bartoldeman@users.sourceforge.net>\nSigned-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "annotation": "[Mandatory] ID: \nCVE-2007-2878\n\n[Mandatory] Title: CVE-2007-2878 / CWE-NVD-CWE-Other: VFAT compat ioctl buffer overflow on 64-bit systems\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: 2007-06-15 — Patch release: 2007-06-15\n\n[Optional] Affected products/versions:\nLinux kernel 2.6.x on x86-64 systems with VFAT filesystem support\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n Buffer overflow due to incorrect handling of 32-bit ioctl structures on 64-bit systems\n[Mandatory] Summary:\nThe VFAT filesystem driver in the Linux kernel incorrectly handles VFAT_IOCTL_READDIR_BOTH and VFAT_IOCTL_READDIR_SHORT ioctls when called from 32-bit applications on 64-bit systems. The kernel_dirent structure has different field sizes between 32-bit and 64-bit, causing buffer misalignment and memory corruption when copying data between user and kernel space. This leads to garbage data and segmentation faults.\n[Mandatory] Root cause:\nIncorrect handling of 32/64-bit structure alignment for kernel_dirent in VFAT ioctl handlers\n[Mandatory] Attack Surface:\nVFAT filesystem driver ioctl interface\n[Mandatory] Impact Summary: \nLocal denial of service (SIGSEGV) and potential information disclosure\n[Optional] Trigger / Attack vector:\nVFAT_IOCTL_READDIR_BOTH or VFAT_IOCTL_READDIR_SHORT ioctl calls from 32-bit applications\n[Mandatory] Key code/struct excerpt (minimal):\n\nstruct kernel_dirent {\n         long            d_ino;\n         long            d_off;\n         unsigned short  d_reclen;\n         char            d_name[256];\n};\n#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, struct kernel_dirent [2])\n#define VFAT_IOCTL_READDIR_SHORT  _IOR('r', 2, struct kernel_dirent [2])\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nVFAT filesystem ioctl interface\n\n[Mandatory] Exploit primitive(s) available:\nMemory corruption through buffer misalignment\n\n[Mandatory] Exploitability summary (1 sentence):\nExploitable by local users with filesystem access, causing denial of service through SIGSEGV\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Open a directory on a VFAT or msdos filesystem\n- Allocate kernel_dirent array for ioctl\n- Call VFAT_IOCTL_READDIR_BOTH with 32-bit compilation on 64-bit system\n- Trigger buffer overflow through structure size mismatch\n- Result: garbage data in kernel_dirent fields followed by SIGSEGV\n\nFix\n[Mandatory] Fix code:\nNA\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNA\n[Optional] Patch Analysis:\nNA\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n- Review other filesystem ioctl handlers for similar 32/64-bit compatibility issues\n- Check for similar structure alignment problems in other kernel subsystems\n- Audit ioctl handlers that pass structures with pointer-sized fields\n\n[Optional] Likely variants/impact (one line):\nSimilar issues likely exist in other filesystem drivers with ioctl interfaces\n\nEND INSTRUCTION.",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 2768,
            "output_tokens": 721
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "NVD-CWE-Other",
        "CVE": "CVE-2007-2878",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "static int vfat_ioctl32(unsigned fd, unsigned cmd, unsigned long arg)\n{\n\tstruct compat_dirent __user *p = compat_ptr(arg);\n\tint ret;\n\tmm_segment_t oldfs = get_fs();\n\tstruct dirent d[2];\n\n\tswitch(cmd)\n\t{\n        \tcase VFAT_IOCTL_READDIR_BOTH32:\n                \tcmd = VFAT_IOCTL_READDIR_BOTH;\n                \tbreak;\n        \tcase VFAT_IOCTL_READDIR_SHORT32:\n                \tcmd = VFAT_IOCTL_READDIR_SHORT;\n                \tbreak;\n\t}\n\n\tset_fs(KERNEL_DS);\n\tret = sys_ioctl(fd,cmd,(unsigned long)&d);\n\tset_fs(oldfs);\n\tif (ret >= 0) {\n\t\tret |= put_dirent32(&d[0], p);\n\t\tret |= put_dirent32(&d[1], p + 1);\n\t}\n\treturn ret;\n}"
        },
        "vulnerabilities": "[PATCH] BLOCK: Move the msdos device ioctl compat stuff to the msdos driver [try #6]\n\nMove the msdos device ioctl compat stuff from fs/compat_ioctl.c to the msdos\ndriver so that the msdos header file doesn't need to be included.\n\nSigned-Off-By: David Howells <dhowells@redhat.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "annotation": "{\"validation_error\": {\"files\": \"Expected object but got string 'NA'\", \"vulnerabilities\": \"Expected string describing vulnerability but got patch description\", \"CWE\": \"CWE must match /^CWE-\\\\d+$/ or be 'NA'; got 'NVD-CWE-Other'\"}}",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 1814,
            "output_tokens": 64
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "NVD-CWE-Other",
        "CVE": "CVE-2007-2878",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "put_dirent32 (struct dirent *d, struct compat_dirent __user *d32)\n{\n        if (!access_ok(VERIFY_WRITE, d32, sizeof(struct compat_dirent)))\n                return -EFAULT;\n\n        __put_user(d->d_ino, &d32->d_ino);\n        __put_user(d->d_off, &d32->d_off);\n        __put_user(d->d_reclen, &d32->d_reclen);\n        if (__copy_to_user(d32->d_name, d->d_name, d->d_reclen))\n\t\treturn -EFAULT;\n\n        return 0;\n}"
        },
        "vulnerabilities": "[PATCH] BLOCK: Move the msdos device ioctl compat stuff to the msdos driver [try #6]\n\nMove the msdos device ioctl compat stuff from fs/compat_ioctl.c to the msdos\ndriver so that the msdos header file doesn't need to be included.\n\nSigned-Off-By: David Howells <dhowells@redhat.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "annotation": "[Mandatory] ID: \nCVE-2007-2878\n\n[Mandatory] Title: CVE-2007-2878 / CWE-NVD-CWE-Other: \nMSDOS device ioctl compatibility handling\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nNot available in input\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n NVD-CWE-Other\n[Mandatory] Summary:\nThe vulnerability involves improper handling of MSDOS device ioctl compatibility code in the Linux kernel. The issue was addressed by moving the MSDOS device ioctl compatibility handling from fs/compat_ioctl.c to the MSDOS driver to avoid including the MSDOS header file. The exact technical details of the vulnerability are not provided in the available input.\n[Mandatory] Root cause:\nNot available in input\n[Mandatory] Attack Surface:\nNot available in input\n[Mandatory] Impact Summary: \nNot available in input\n[Optional] Trigger / Attack vector:\nNot available in input\n[Mandatory] Key code/struct excerpt (minimal):\n\nNot available in input\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nNot available in input\n\n[Mandatory] Exploit primitive(s) available:\nNot available in input\n\n[Mandatory] Exploitability summary (1 sentence):\nNot available in input\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n\nFix\n[Mandatory] Fix code:\nNot available in input\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nhttps://github.com/wagner-group/diversevul?tab=readme-ov-file\n[Optional] Patch Analysis:\n [Short note: \"What did the fix do?\"\n - Field: PatchType Not available in input\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n\nNot available in input\n\n[Optional] Likely variants/impact (one line):\nNot available in input\n\nEND INSTRUCTION.",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 1814,
            "output_tokens": 431
        }
    },
    {
        "vulnerable": 1,
        "snippet_type": "function",
        "CWE": "CWE-20",
        "CVE": "CVE-2007-3731",
        "language": "C",
        "synthetic": 0,
        "source": "DiverseVul",
        "source_link": "https://github.com/wagner-group/diversevul?tab=readme-ov-file",
        "files": {
            "NA": "unsigned long convert_rip_to_linear(struct task_struct *child, struct pt_regs *regs)\n{\n\tunsigned long addr, seg;\n\n\taddr = regs->rip;\n\tseg = regs->cs & 0xffff;\n\n\t/*\n\t * We'll assume that the code segments in the GDT\n\t * are all zero-based. That is largely true: the\n\t * TLS segments are used for data, and the PNPBIOS\n\t * and APM bios ones we just ignore here.\n\t */\n\tif (seg & LDT_SEGMENT) {\n\t\tu32 *desc;\n\t\tunsigned long base;\n\n\t\tdown(&child->mm->context.sem);\n\t\tdesc = child->mm->context.ldt + (seg & ~7);\n\t\tbase = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);\n\n\t\t/* 16-bit code segment? */\n\t\tif (!((desc[1] >> 22) & 1))\n\t\t\taddr &= 0xffff;\n\t\taddr += base;\n\t\tup(&child->mm->context.sem);\n\t}\n\treturn addr;\n}"
        },
        "vulnerabilities": "Handle bogus %cs selector in single-step instruction decoding\n\nThe code for LDT segment selectors was not robust in the face of a bogus\nselector set in %cs via ptrace before the single-step was done.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "annotation": "[Mandatory] ID: \nCVE-2007-3731\n\n[Mandatory] Title: CVE-2007-3731 / CWE-20: Handle bogus %cs selector in single-step instruction decoding\n\n[Optional] Disclosure / Patch Dates:\nInitial advisory: Not available in input — Patch release: Not available in input\n\n[Optional] Affected products/versions:\nNot available in input\n\nThe Vulnerability\n[Optional] CWE/CVE Number and description:\n Improper input validation (CWE-20)\n[Mandatory] Summary:\nThe vulnerability exists in the Linux kernel's single-step instruction decoding logic where LDT segment selectors are processed. When a bogus selector is set in the %cs register via ptrace before single-stepping, the code fails to validate the selector properly, leading to undefined behavior. This occurs during debugging operations when a traced process is single-stepped with an invalid code segment selector.\n[Mandatory] Root cause:\nMissing validation of %cs selector values when processing LDT segment selectors during single-step instruction decoding.\n[Mandatory] Attack Surface:\nptrace debugging interface\n[Mandatory] Impact Summary: \nLocal privilege escalation\n[Optional] Trigger / Attack vector:\nptrace system call with bogus %cs selector followed by single-step operation\n\n[Mandatory] Key code/struct excerpt (minimal):\n\nNot available in input\n\nExploit:\n\n[Mandatory] Trigger surface/attack vector:\nptrace debugging interface\n\n[Mandatory] Exploit primitive(s) available:\nArbitrary code execution in kernel context\n\n[Mandatory] Exploitability summary (1 sentence):\nExploitation requires local access and ability to ptrace a target process, but the lack of validation makes reliable exploitation feasible.\n\n[Mandatory] Exploit script (summary, 3–6 bullets):\n- Attach to target process via ptrace\n- Set bogus %cs selector value in process context\n- Initiate single-step debugging operation\n- Trigger undefined behavior in segment selector handling\n- Gain kernel code execution\n- Escalate privileges\n\nFix\n[Mandatory] Fix code:\nNot available in input\n\n[Mandatory] Fix summary:\nNot available in input\n[Optional] Patch reference:\nNot available in input\n[Optional] Patch Analysis:\nNot available in input\n[Optional] Variant & Triage Guidance\n\n[Optional] Variant analysis suggestions (2–3 bullets):\n- Review other segment selector handling code paths\n- Audit ptrace interface for similar validation issues\n- Check other debugging operations for selector validation\n\n[Optional] Likely variants/impact (one line):\nSimilar issues may exist in other segment selector validation paths.\n\nEND",
        "tests": "NA",
        "solutions": "NA",
        "annotation_metadata": {
            "model": "kwaipilot/kat-coder-pro:free",
            "input_tokens": 1783,
            "output_tokens": 533
        }
    }
]